const moment = require('moment-timezone');
const { serverDateFormat, creationTypes, autofillDistributions, workoutTypes, roundToOneDecimal} = require('./backend_configs');
const { addWorkouts, updateWorkouts } = require('./workout_handlers');

// Returns true/false for if all the workouts in the list are autogenerated
const areWorkoutsSameCreationType = (workoutList, creation) => {
    return workoutList.reduce((all, cur) => all && (cur.payload.creationType === creation), true);
}

// This function is idempotent on existing autogenerated workouts, 
// assuming imputs (user workouts, goalValue) are the same.
const generateAutofillWorkouts = (existingWorkouts, goalPayload, userConfig, ownerID, callback) => {
    let numDaysToFill = 0;
    let allocatedTotal = 0;
    let newWorkouts = [];
    let updatedWorkouts = [];
    let days = {}; // key = date, value = list of workouts on that day, if any

    // Sort workouts by day
    let currentDay = moment(goalPayload.startDate);
    while (!currentDay.isAfter(moment(goalPayload.endDate))) { // Weeks are defined by their start and end inclusively
        const date = currentDay.format(serverDateFormat);
        const existingWorkoutsOnThisDate = existingWorkouts.filter(workout => moment(workout.payload.startDate).isSame(currentDay, 'day'));
        days[date] = existingWorkoutsOnThisDate; // will return [] if no workouts on that day
        currentDay.add(1, "day");
    }

    // Calculate how many days/miles we have to work with
    Object.values(days).forEach(workoutList => {
        if (workoutList.length === 0 || areWorkoutsSameCreationType(workoutList, creationTypes.AUTOFILLWEEK)) {
            numDaysToFill += 1;
        } else {
            // TODO need to consider completed workouts
            allocatedTotal += workoutList.reduce((mileage, workout) => { return (mileage + workout.payload.mileage.goal) }, 0);
        }
    });

    // Short circuit if we're already past the goal
    if (allocatedTotal >= goalPayload.goalValue) {
        callback({ added: [], updated: []});
        return;
    }

    // Fill the open days according to the user's chosen distribution
    if (userConfig.autofillConfig.distribution === autofillDistributions.EVEN) {
        let mileages;
        // const dailyMileage = roundToOneDecimal((goalPayload.goalValue - allocatedTotal) / numDaysToFill);
        // mileages = Array(numDaysToFill).fill(dailyMileage);

        // Alt method, where mileage comes out to half or whole values
        // Note: this is slightly overengineered to allow for (potential future) handling of non-integer goal values
        const base = Math.round((goalPayload.goalValue - allocatedTotal) / numDaysToFill);
        const diff = goalPayload.goalValue - (allocatedTotal + (base * numDaysToFill));
        let numDaysWithAdjustment = Math.ceil(Math.abs(diff) / 0.5);
      
        // Because base round to the integer, it misses the case where the true even 
        // distribution is x.5 for all days. The Number.isInteger() check catches this case.
        //
        // Because our numDaysWithAdjustment calc is ceil, we will overcount the number of
        // days that need adjustment if our base value has overshot the goal (diff is negative). 
        // Therefore we need to reduce the days by 1 so we're never more than .5 miles over the goal.
        if (!Number.isInteger(Math.abs(diff) / 0.5) && diff < 0) {
          numDaysWithAdjustment -= 1;
        }

        if (numDaysWithAdjustment > 0) {
            const adjustmentDirection = diff > 0 ? 1 : -1;
            const adjustedMileage = base + (adjustmentDirection * .5);
            mileages = 
                Array(numDaysWithAdjustment).fill(adjustedMileage)
                .concat(Array(numDaysToFill - numDaysWithAdjustment).fill(base));
        } else {
            mileages = Array(numDaysToFill).fill(base);
        }

        const templateWorkout = {
            owner: ownerID,
            payload: {
                startDate: "",
                content: "Auto-populated mileage run",
                type: workoutTypes.RECOVERY,
                mileage: {},
                creationType: creationTypes.AUTOFILLWEEK,
            }
        };

        let mileageIdx = 0;
        for (let date in days) {
            // No existing autogenerated workouts, make new ones
            if (days[date].length === 0) {
                // const workout = {...templateWorkout}; // IDK
                const workout = JSON.parse(JSON.stringify(templateWorkout));

                let startDatetime = moment(date);
                startDatetime.hour(userConfig.defaultStartTime.hour);
                startDatetime.minute(userConfig.defaultStartTime.minute);
                startDate = moment.tz(startDatetime, this.mainTimezone);
                workout.payload.startDate = startDatetime.toISOString();
                workout.payload.mileage.goal = mileages[mileageIdx];

                newWorkouts.push(workout);
                mileageIdx += 1;

                // Just update the existing autogenerated workouts
            } else if (areWorkoutsSameCreationType(days[date], creationTypes.AUTOFILLWEEK)) {
                days[date].forEach(existingAutogeneratedWorkout => {
                    const updatedWorkout = JSON.parse(JSON.stringify(existingAutogeneratedWorkout));
                    updatedWorkout.payload.mileage.goal = mileages[mileageIdx];
                    updatedWorkouts.push(updatedWorkout);

                    mileageIdx += 1;
                });
            }
        }
    } else if (config.autofillConfig.distribution === autofillDistributions.RANDOM) {

    }

    // Actually store the workouts.
    // Can't do res.json twice, so have to collate into one call.
    let returnedNewWorkouts;
    let returnedUpdatedWorkouts;

    const p1 = new Promise(function (resolve, reject) {
        addWorkouts(newWorkouts, ownerID,
            (returned) => {
                returnedNewWorkouts = returned;
                resolve();
            },
            () => {
                returnedNewWorkouts = null;
                reject();
            }
        );
    });

    const p2 = new Promise(function (resolve, reject) {
        updateWorkouts(updatedWorkouts, ownerID,
            (returned) => {
                returnedUpdatedWorkouts = returned;
                resolve();
            },
            () => {
                returnedUpdatedWorkouts = null;
                reject();
            }
        );
    });

    Promise.all([p1, p2]).then(
        () => { callback({ added: returnedNewWorkouts, updated: returnedUpdatedWorkouts }) },
        () => { callback(null) }
    );
}

exports.areWorkoutsSameCreationType = areWorkoutsSameCreationType;
exports.generateAutofillWorkouts = generateAutofillWorkouts;