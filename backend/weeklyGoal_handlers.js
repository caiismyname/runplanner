const moment = require('moment-timezone');
const {serverDateFormat, creationTypes, autofillDistributions} = require('./backend_configs');
const {addWorkouts, updateWorkouts} = require('./workout_handlers');

// Returns true/false for if all the workouts in the list are autogenerated
const areWorkoutsSameCreationType = (workoutList, creation) => {
    return workoutList.reduce((all, cur) => all && (cur.payload.creationType === creation), true);
}

// This function is idempotent on existing autogenerated workouts, 
// assuming imputs (user workouts, goalValue) are the same.
const generateAutofillWorkouts = (existingWorkouts, goalPayload, userConfig, ownerID, callback) => {
    let numDaysToFill = 0;
    let allocatedTotal = 0;
    let newWorkouts = [];
    let updatedWorkouts = [];
    let days = {}; // key = date, value = list of workouts on that day, if any

    // Sort workouts by day
    let currentDay = moment(goalPayload.startDate);
    while (!currentDay.isAfter(moment(goalPayload.endDate))) { // Weeks are defined by their start and end inclusively
        const date = currentDay.format(serverDateFormat);
        const existingWorkoutsOnThisDate = existingWorkouts.filter(workout => moment(workout.payload.startDate).isSame(currentDay, 'day'));
        days[date] = existingWorkoutsOnThisDate; // will return [] if no workouts on that day
        currentDay.add(1, "day");
    }

    // Calculate how many days/miles we have to work with
    Object.values(days).forEach(workoutList => {
        if (workoutList.length === 0 || areWorkoutsSameCreationType(workoutList, creationTypes.AUTOFILLWEEK)) {
            numDaysToFill += 1;
        } else {
            // TODO need to consider completed workouts
            allocatedTotal += workoutList.reduce((milage, workout) => {return(milage + workout.payload.milage.goal)}, 0);
        }
    });

    // Fill the open days according to the user's chosen distribution
    if (userConfig.autofillConfig.distribution === autofillDistributions.EVEN) {
        const dailyMilage = (goalPayload.goalValue - allocatedTotal) / numDaysToFill;
        const templateWorkout = {
            owner: ownerID,
            payload: {
                startDate: "",
                content: "Auto-populated milage run",
                type: "Recovery Run",
                milage: {
                  goal: dailyMilage,
                },
                creationType: creationTypes.AUTOFILLWEEK,
            }
        };

        for (let date in days) {
            // No existing autogenerated workouts, make new ones
            if (days[date].length === 0) { 
                // const workout = {...templateWorkout}; // IDK
                const workout = JSON.parse(JSON.stringify(templateWorkout));
                
                let startDatetime = moment(date);
                startDatetime.hour(userConfig.defaultStartTime.hour);
                startDatetime.minute(userConfig.defaultStartTime.minute);
                startDate = moment.tz(startDatetime, this.mainTimezone);
                workout.payload.startDate = startDatetime.toISOString();

                newWorkouts.push(workout);
            
            // Just update the existing autogenerated workouts
            } else if (areWorkoutsSameCreationType(days[date], creationTypes.AUTOFILLWEEK)) {
                days[date].forEach(existingAutogeneratedWorkout => {
                    const updatedWorkout = JSON.parse(JSON.stringify(existingAutogeneratedWorkout));
                    updatedWorkout.payload.milage.goal = dailyMilage;
                    updatedWorkouts.push(updatedWorkout);
                });
            }
        }
    } else if (config.autofillConfig.distribution === autofillDistributions.RANDOM) {

    }

    // Actually store the workouts.
    // Can't do res.json twice, so have to collate into one call.
    let returnedNewWorkouts;
    let returnedUpdatedWorkouts;

    const p1 = new Promise(function(resolve, reject) {
        addWorkouts(newWorkouts, ownerID, 
            (returned) => {
                returnedNewWorkouts = returned;
                resolve();
            },
            () => {
                returnedNewWorkouts = null;
                reject();
            }
        );
    });
    
    const p2 = new Promise(function(resolve, reject) {
        updateWorkouts(updatedWorkouts, ownerID, 
            (returned) => {
                returnedUpdatedWorkouts = returned;
                resolve();
            },
            () => {
                returnedUpdatedWorkouts = null;
                reject();
            }
        );
    });

    Promise.all([p1, p2]).then(
        () => {callback({added: returnedNewWorkouts, updated: returnedUpdatedWorkouts})},
        () => {callback(null)}
    );
}

exports.areWorkoutsSameCreationType = areWorkoutsSameCreationType;
exports.generateAutofillWorkouts = generateAutofillWorkouts;